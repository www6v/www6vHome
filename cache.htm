<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:黑体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:黑体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@黑体";
	panose-1:2 1 6 9 6 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman","serif";}
h1
	{margin-right:0cm;
	margin-left:0cm;
	font-size:24.0pt;
	font-family:宋体;
	font-weight:bold;}
h2
	{margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Arial","sans-serif";
	font-weight:bold;}
h3
	{margin-top:13.0pt;
	margin-right:0cm;
	margin-bottom:13.0pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:173%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Times New Roman","serif";
	font-weight:bold;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman","serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p
	{margin-right:0cm;
	margin-left:0cm;
	font-size:12.0pt;
	font-family:宋体;}
span.Char
	{mso-style-name:"页眉 Char";
	mso-style-link:页眉;}
span.Char0
	{mso-style-name:"页脚 Char";
	mso-style-link:页脚;}
 /* Page Definitions */
 @page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=Section1 style='layout-grid:15.6pt'>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span lang=EN-US style='font-size:22.0pt'>&nbsp;&nbsp;</span><span
style='font-size:22.0pt;font-family:宋体'>缓存机制</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><b><span
style='font-size:12.0pt;font-family:宋体'>缓存数据分布模式</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; 1. </span><span
style='font-size:12.0pt;font-family:宋体'>分片模式</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>（</span><span lang=EN-US
style='font-size:12.0pt'>sharding</span><span style='font-size:12.0pt;
font-family:宋体'>）</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>数据正交分散到大量机器，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>可以做到线性的可伸缩性，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>但是实现可用性比较困难。还有一个好处是可以通过集群做负载均衡来实现数据的管理。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>根据</span><span lang=EN-US style='font-size:12.0pt'>CAP</span><span
style='font-size:12.0pt;font-family:宋体'>理论，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>在高可用的场景下，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>数据分区的容忍性需要牺牲一定的一致性。</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>相应各个副本的同步策略也有不同，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>主要可分为同步和异步方式。</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>由客户端做一致性</span><span lang=EN-US
style='font-size:12.0pt'>hash</span><span style='font-size:12.0pt;font-family:
宋体'>把数据分片存放到服务端。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;
</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; 2. </span><span
style='font-size:12.0pt;font-family:宋体'>复制模式</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span style='font-size:12.0pt;
font-family:宋体'>数据在集群中存在多个副本。</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>在本地缓存的集群中，数据会复制到所有的节点中，没有网络延迟和等待时间的集群成员都是可用的。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>多副本通过低延迟访问来提供高性能。</span></p>

<p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>在修改数据时需要复制新的版本数据到所有的副本，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>在高并发修改的场景下会限制系统的可伸缩性，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>副本数不会调的太高。</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>本地缓存</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:18.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span style='font-size:
12.0pt;font-family:宋体'>在同一机房内的，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>需要适量考虑本地</span><span lang=EN-US
style='font-size:12.0pt'>cache</span><span style='font-size:12.0pt;font-family:
宋体'>，</span><span style='font-size:12.0pt'> </span><span style='font-size:12.0pt;
font-family:宋体'>数据压缩传输等以节省内网数据传输量</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>。</span></p>

<p class=MsoNormal style='margin-left:18.0pt;text-indent:-18.0pt'><span
style='font-size:12.0pt;font-family:宋体'>跨机房的缓存有地域区分，用户往往访问同一机房，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>这样可以做本地的</span><span lang=EN-US style='font-size:12.0pt'>cache</span><span
style='font-size:12.0pt;font-family:宋体'>。</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>机房之间通过队列的方式进行异步和压缩传输，以提高用户请求的相应度。</span><span
lang=EN-US style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='margin-left:18.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>过期策略：</span><span style='font-size:
12.0pt'> </span></p>

<p class=MsoNormal style='margin-left:49.5pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>被动过期</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>（一致性低，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>缓存超时）</span></p>

<p class=MsoNormal style='margin-left:31.5pt'><span style='font-size:12.0pt;
font-family:宋体'>对一致性要求较低的系统，可以采用常规的缓存超时策略，此类策略属于被动过期。</span></p>

<p class=MsoNormal style='text-indent:36.0pt'><span style='font-size:12.0pt;
font-family:宋体'>存放数据时，永不过期的数据不要与有过期策略的数据放在一起，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>早期的版本</span><span
lang=EN-US style='font-size:12.0pt'>memcache</span><span style='font-size:12.0pt;
font-family:宋体'>曾经有一个这样的</span><span lang=EN-US style='font-size:12.0pt'>bug</span><span
style='font-size:12.0pt;font-family:宋体'>，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>永不过期的数据被有过期策略的数据踢走了。不要把所有的数据的过期时间设为同一个时间，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>这样可能造成大规模的数据同时过期，</span><span lang=EN-US style='font-size:12.0pt'>hit rate</span><span
style='font-size:12.0pt;font-family:宋体'>变小，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>对数据库的查询数瞬时变大，造成数据库的压力。</span><span
lang=EN-US style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:49.5pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>主动过期（一致性高，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>事件过期，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>异步过期，</span><span lang=EN-US style='font-size:12.0pt'>&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>变化事件）</span></p>

<p class=MsoNormal style='margin-left:31.5pt'><span style='font-size:12.0pt;
font-family:宋体'>对一致性要求较高的系统，可以采用事件过期策略，此类策略属于主动过期。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;</span><span style='font-size:12.0pt;font-family:宋体'>某个组件的结构发生变化，或者某个业务对象状态发生变化，把组件</span><span
lang=EN-US style='font-size:12.0pt'>id</span><span style='font-size:12.0pt;
font-family:宋体'>或业务对象</span><span lang=EN-US style='font-size:12.0pt'>id</span><span
style='font-size:12.0pt;font-family:宋体'>放入过期队列中，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>缓存节点异步读取这些数据，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>将对应</span><span lang=EN-US style='font-size:12.0pt'>cache</span><span
style='font-size:12.0pt;font-family:宋体'>的对象移除。亦可把变化封装成事件放入过期队列中，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>由代理处理这个事件，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>异步的移除相应的缓存。</span><span
style='font-size:12.0pt'> <span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3. </span><span style='font-size:12.0pt;font-family:宋体'>基于版本的过期方式</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>在存储空间较大的前提下，借鉴</span><span
lang=EN-US style='font-size:12.0pt'>mvcc</span><span style='font-size:12.0pt;
font-family:宋体'>的概念，每次更改数据时增加一个副本，并带版本号元数据。</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>然后由一个代理定时的删除低版本的过期的数据。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>服务端缓存</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存服务端常用的有</span><span lang=EN-US
style='font-size:12.0pt'>memcache</span><span style='font-size:12.0pt;
font-family:宋体'>。</span><span lang=EN-US style='font-size:12.0pt'> Nosql</span><span
style='font-size:12.0pt;font-family:宋体'>的解决方案有</span><span lang=EN-US
style='font-size:12.0pt'>Redies</span><span style='font-size:12.0pt;font-family:
宋体'>，</span><span lang=EN-US style='font-size:12.0pt'>Redies</span><span
style='font-size:12.0pt;font-family:宋体'>在作为</span><span lang=EN-US
style='font-size:12.0pt'>cache</span><span style='font-size:12.0pt;font-family:
宋体'>时往往配置为无持久化的形式</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>。两者数据模型都是</span><span lang=EN-US
style='font-size:12.0pt'>key-value</span><span style='font-size:12.0pt;
font-family:宋体'>的。</span><span style='font-size:12.0pt'> <span lang=EN-US>Redies</span></span><span
style='font-size:12.0pt;font-family:宋体'>比老牌的</span><span lang=EN-US
style='font-size:12.0pt'>memcache</span><span style='font-size:12.0pt;
font-family:宋体'>能提供更好的性能，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>更快的速度。</span><span style='font-size:
12.0pt'> <span lang=EN-US>Memcache </span></span><span style='font-size:12.0pt;
font-family:宋体'>没有自建的</span><span lang=EN-US style='font-size:12.0pt'>replicaion
</span><span style='font-size:12.0pt;font-family:宋体'>机制</span><span lang=EN-US
style='font-size:12.0pt'>, </span><span style='font-size:12.0pt;font-family:
宋体'>可靠性需要在客户端以双写支持。</span><span style='font-size:12.0pt'> <span lang=EN-US>Redies</span></span><span
style='font-size:12.0pt;font-family:宋体'>可以看成自带持久化机制的</span><span lang=EN-US
style='font-size:12.0pt'>Write-back</span><span style='font-size:12.0pt;
font-family:宋体'>缓存，在</span><span lang=EN-US style='font-size:12.0pt'>write-behind</span><span
style='font-size:12.0pt;font-family:宋体'>缓存中，数据的读取和更新通过缓存进行，与</span><span
lang=EN-US style='font-size:12.0pt'>write-through</span><span style='font-size:
12.0pt;font-family:宋体'>缓存不同，更新的数据并不会立即持久化。相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到外部存储中，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>在</span><span lang=EN-US style='font-size:12.0pt'>Redies</span><span
style='font-size:12.0pt;font-family:宋体'>中这种机制叫做</span><span lang=EN-US
style='font-size:12.0pt'>AOF</span><span style='font-size:12.0pt;font-family:
宋体'>。</span><span lang=EN-US style='font-size:12.0pt'> r</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></b><b><span
style='font-size:12.0pt;font-family:宋体'>缓存分层</span></b></p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>1<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>边缘</span><span
lang=EN-US style='font-size:12.0pt'>cache: </span><span style='font-size:12.0pt;
font-family:宋体'>可用</span><span lang=EN-US style='font-size:12.0pt'>CDN</span><span
style='font-size:12.0pt;font-family:宋体'>实现，往往是服务器端缓存，存静态数据。</span></p>

<p class=MsoNormal style='margin-left:34.5pt'><span style='font-size:12.0pt;
font-family:宋体'>可以存</span><span lang=EN-US style='font-size:12.0pt'>Html</span><span
style='font-size:12.0pt;font-family:宋体'>页面，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>脚本，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>样式，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>图片，页面片段等。</span></p>

<p class=MsoNormal style='margin-left:36.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-size:12.0pt'>2<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>页面级缓存：</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>往往是本地缓存，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>数据相对动态。</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>3&nbsp;&nbsp;&nbsp; </span><span style='font-size:
12.0pt;font-family:宋体'>逻辑缓存</span><span lang=EN-US style='font-size:12.0pt'>:&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>逻辑计算结果的缓存</span><span
lang=EN-US style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='margin-left:34.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:34.55pt;text-indent:12.0pt'><span
style='font-size:12.0pt;font-family:宋体'>可以存储索引聚合数据，比如</span><span lang=EN-US
style='font-size:12.0pt'>&nbsp; BI</span><span style='font-size:12.0pt;
font-family:宋体'>里的数据聚合表。也可以存储耗时查询数据</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>，比如搜索的结果。也可以存储业务相关数据，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>比如对象模型的有向图可以整个缓存起来。在微博系统中，所有</span><span lang=EN-US style='font-size:12.0pt'>@</span><span
style='font-size:12.0pt;font-family:宋体'>你的微博是相对耗时，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>可以</span><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span><span
style='font-size:12.0pt;font-family:宋体'>考虑作为逻辑缓存。</span></p>

<p class=MsoNormal style='text-indent:42.0pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=EN-US
style='font-size:12.0pt'>4</span><span style='font-size:12.0pt;font-family:
宋体'>．</span><span style='font-size:12.0pt'> </span><span style='font-size:12.0pt;
font-family:宋体'>数据源级缓存：</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>缓存数据源结果集</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal style='margin-left:34.5pt'><span style='font-size:12.0pt;
font-family:宋体'>比如</span><span lang=EN-US style='font-size:12.0pt'>Hibernate</span><span
style='font-size:12.0pt;font-family:宋体'>缓存中的</span><span lang=EN-US
style='font-size:12.0pt'>QueryCache</span><span style='font-size:12.0pt;
font-family:宋体'>用来缓存查询语句</span><span lang=EN-US style='font-size:12.0pt'>, </span><span
style='font-size:12.0pt;font-family:宋体'>及查询结果集中对象的</span><span lang=EN-US
style='font-size:12.0pt'>Id</span><span style='font-size:12.0pt;font-family:
宋体'>与</span><span lang=EN-US style='font-size:12.0pt'>Type. </span><span
style='font-size:12.0pt;font-family:宋体'>当再次使用已缓存的</span><span lang=EN-US
style='font-size:12.0pt'>Query</span><span style='font-size:12.0pt;font-family:
宋体'>时</span><span lang=EN-US style='font-size:12.0pt'>, </span><span
style='font-size:12.0pt;font-family:宋体'>就可以通过对象的</span><span lang=EN-US
style='font-size:12.0pt'>Id</span><span style='font-size:12.0pt;font-family:
宋体'>与</span><span lang=EN-US style='font-size:12.0pt'>Type</span><span
style='font-size:12.0pt;font-family:宋体'>在二级缓存中查找实际的对象</span><span lang=EN-US
style='font-size:12.0pt'>.</span></p>

<p class=MsoNormal style='margin-left:34.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:34.55pt'><span lang=EN-US
style='font-size:12.0pt'>Hibernate</span><span style='font-size:12.0pt;
font-family:宋体'>提供了短生命周期的缓存，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>也叫事务级别的缓存。长生命周期的缓存，也叫应用级别的缓存。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; </span><span style='font-size:12.0pt;
font-family:宋体'>缓存分层之间的失效方式：</span><span lang=EN-US style='font-size:12.0pt'>
1. </span><span style='font-size:12.0pt;font-family:宋体'>映射关系</span><span
lang=EN-US style='font-size:12.0pt'>&nbsp; 2. </span><span style='font-size:
12.0pt;font-family:宋体'>日志</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>＋</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>重试</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>缓存对象的粒度</span></b><b><span
lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></b></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:30.0pt'><span style='font-size:12.0pt;
font-family:宋体'>有一种缓存的误用是缓存大量的数据集合，而读取其中一部分。</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>在很多时候，我们往往会缓存一个对象的集合，但是，我们在读取的时候，只是每次读取其中一部分。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>在更新缓存时，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>读出整个集合，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>改变其中一部分后，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>在存回去，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>这样序列化与反序列化的代价相当大。</span></p>

<p class=MsoNormal style='text-indent:30.0pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span style='font-size:12.0pt;
font-family:宋体'>针对这个情况，</span><span lang=EN-US style='font-size:12.0pt'> jboss
cache</span><span style='font-size:12.0pt;font-family:宋体'>提供了两种粒度的对象存储：核心缓存（粗粒度的），</span><span
lang=EN-US style='font-size:12.0pt'>POJO </span><span style='font-size:12.0pt;
font-family:宋体'>缓存（细粒度的）。</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span style='font-size:12.0pt;
font-family:宋体'>核心缓存会直接把您传递给它的数据存储在一个树型结构中。键／值对被存储在树的节点上，出于复制或持续性的需要它们都被序列化了。</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=EN-US
style='font-size:12.0pt'>POJO </span><span style='font-size:12.0pt;font-family:
宋体'>缓存则采用比较复杂的机制</span><span lang=EN-US style='font-size:12.0pt'>——</span><span
style='font-size:12.0pt;font-family:宋体'>利用字节码编织来内省（</span><span lang=EN-US
style='font-size:12.0pt'>introspecting</span><span style='font-size:12.0pt;
font-family:宋体'>）用户类，并向用户类的域添加侦听器，一旦域值有任何变化，侦听器会立刻</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>通知缓存。例如，如果要在</span><span lang=EN-US style='font-size:12.0pt'>POJO</span><span
style='font-size:12.0pt;font-family:宋体'>缓存中存储一个庞大、复杂的对象，会导致</span><span
lang=EN-US style='font-size:12.0pt'>POJO</span><span style='font-size:12.0pt;
font-family:宋体'>缓存内省对象的字节码，最终只把该对象的原始域存储到树结构中。一旦域</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>值有所变化，缓存只复制这个改变了的域值而不会去复制整个用户类，这是高效的细粒度复制。</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span style='font-size:12.0pt;
font-family:宋体'>在缓存了细粒度的对象后，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>造成的一个问题是数据的冗余。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>例如查询条件</span><span lang=EN-US style='font-size:12.0pt'>1</span><span
style='font-size:12.0pt;font-family:宋体'>的返回的是</span><span lang=EN-US
style='font-size:12.0pt'>model1, model2, model3, </span><span style='font-size:
12.0pt;font-family:宋体'>查询条件</span><span lang=EN-US style='font-size:12.0pt'>2</span><span
style='font-size:12.0pt;font-family:宋体'>返回的是</span><span lang=EN-US
style='font-size:12.0pt'>model2, model3, model4. model2, model3</span><span
style='font-size:12.0pt;font-family:宋体'>在缓存里就存了两份，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>造成了冗余。这时可以分离出一个索引层，索引层存储缓存对象的地址，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>这样可以节约大量的存储空间。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>例如可以存储</span><span lang=EN-US style='font-size:12.0pt'>model1- model4</span><span
style='font-size:12.0pt;font-family:宋体'>的索引，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>再从缓存中取得到实际的</span><span
lang=EN-US style='font-size:12.0pt'>model. &nbsp;</span><span style='font-size:
12.0pt;font-family:宋体'>在数据库中，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>这种方式叫</span><span lang=EN-US
style='font-size:12.0pt'>look up table. </span><span style='font-size:12.0pt;
font-family:宋体'>如果系统更复杂，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>可以采取缓存的</span><span lang=EN-US
style='font-size:12.0pt'>partition</span><span style='font-size:12.0pt;
font-family:宋体'>加多级索引的方式。</span><span style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='text-indent:24.0pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>缓存与一致性</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存多副本之间的同步：</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>可分为</span><span lang=EN-US
style='font-size:12.0pt'>replication</span><span style='font-size:12.0pt;
font-family:宋体'>和</span><span lang=EN-US style='font-size:12.0pt'>invalidaiton</span><span
style='font-size:12.0pt;font-family:宋体'>机制。</span><span style='font-size:12.0pt'>
<span lang=EN-US>Replication</span></span><span style='font-size:12.0pt;
font-family:宋体'>机制表示一旦有数据的更新，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>其余副本都会同步复制一份更新后的数据。</span><span
lang=EN-US style='font-size:12.0pt'>Replication</span><span style='font-size:
12.0pt;font-family:宋体'>机制复制时</span><span lang=EN-US style='font-size:12.0pt'>slave</span><span
style='font-size:12.0pt;font-family:宋体'>会对</span><span lang=EN-US
style='font-size:12.0pt'>master</span><span style='font-size:12.0pt;font-family:
宋体'>节点有拖累，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>这时可以考虑采取</span><span lang=EN-US style='font-size:12.0pt'>invalidation</span><span
style='font-size:12.0pt;font-family:宋体'>机制。</span><span style='font-size:12.0pt'>
<span lang=EN-US>Invalidation</span></span><span style='font-size:12.0pt;
font-family:宋体'>机制在</span><span lang=EN-US style='font-size:12.0pt'>jboss cache</span><span
style='font-size:12.0pt;font-family:宋体'>里已有实现</span><span lang=EN-US
style='font-size:12.0pt'>, </span><span style='font-size:12.0pt;font-family:
宋体'>一旦有更新，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>广播消息，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>失效所有其他的副本，让其重新去获得该值。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>可通过这种方式缓存大对象以减少在实例中复制对象的代价。根据用户在一定时间段内上网地点固定不变的规律，用户始终都是访问同一个机房，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>针对主节点的本地缓存在有更新时可以异步发</span><span lang=EN-US style='font-size:12.0pt'>invalidation</span><span
style='font-size:12.0pt;font-family:宋体'>消息，副本节点可以慢慢的再加载回这个大对象，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>这样可以提高用户响应度。这种方式也可用在边缘缓存中。对于无法分组的数据，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>比如在某时间段的用户认证数据需要保证副本同步，最好的方式是清除相应的副本，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>让它在下次使用时初始化。</span><span lang=EN-US style='font-size:12.0pt'> r</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存与数据库的数据同步</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>在应用层，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>可以根据业务场景对一致性的要求不同，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>给数据分配不同的队列，即</span></p>

<p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>一致性分级队列。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>强一致性的场景如自己发布的评论，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>自己应该及时看到。</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>而别人看到我的评论属于会话一致性，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>一致性要求比较弱。</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>这样可以把一致性要求高的业务分配更多资源，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>做到快速同步。</span><span style='font-size:12.0pt'> <span lang=EN-US>&nbsp;&nbsp;</span></span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存与数据库同步的异步化也是提高响应度的方式，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>在</span><span lang=EN-US style='font-size:12.0pt'>write-behind</span><span
style='font-size:12.0pt;font-family:宋体'>的方式中，所有的数据的操作都在缓存中，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>更新的数据并不会立即传到数据库。相反，在缓存中一旦进行更新操作，缓存就会跟踪脏记录列表，并定期将当前的脏记录集刷新到数据库中。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>在</span><span lang=EN-US
style='font-size:12.0pt'>DAO</span><span style='font-size:12.0pt;font-family:
宋体'>层的</span><span lang=EN-US style='font-size:12.0pt'>hibernate</span><span
style='font-size:12.0pt;font-family:宋体'>针对一致性的要求提出了类似</span><span lang=EN-US
style='font-size:12.0pt'>DBMS</span><span style='font-size:12.0pt;font-family:
宋体'>的事务级别的</span><span lang=EN-US style='font-size:12.0pt'>4</span><span
style='font-size:12.0pt;font-family:宋体'>个配置项。</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>非严格读写型</span><span
lang=EN-US style='font-size:12.0pt'>(nonstrict-read-write)</span><span
style='font-size:12.0pt;font-family:宋体'>策略提供弱一致性，不保证缓存与数据库中数据的一致性。如果存在两个事务同时访问缓存中相同数据的可能，必须为该数据配置一个很短的数据过期时间，从而尽量避免脏读。对于极少被修改，并且允许偶尔脏读的数据，可以采用这种并发访问策略。</span><span
style='font-size:12.0pt'> </span><strong><span style='font-size:12.0pt;
font-family:宋体'>事务</span></strong><span style='font-size:12.0pt;font-family:
宋体'>策略</span><strong><span lang=EN-US style='font-size:12.0pt'>(</span></strong><span
lang=EN-US style='font-size:12.0pt;color:green'>transactional</span><span
lang=EN-US style='font-size:12.0pt'>&nbsp;<strong>)</strong></span><span
style='font-size:12.0pt;font-family:宋体'>只可用于托管环境，如有必要，它还保证完全的事务隔离级别直到可重复读。<strong><span
style='font-family:宋体'>事务</span></strong>策略可以用在强一致性的场景中。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><b><span style='font-size:12.0pt;font-family:宋体'>缓存与场景</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; 1. </span><span
style='font-size:12.0pt;font-family:宋体'>非共性数据缓存</span><span lang=EN-US
style='font-size:12.0pt'> eg. </span><span style='font-size:12.0pt;font-family:
宋体'>微博，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>博客个人首页</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>问题：缓存所有的数据性价比不高，　命中率不高</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>解决方案：</span><span style='font-size:
12.0pt'> </span></p>

<p class=MsoNormal style='margin-left:73.5pt;text-indent:-36.0pt'><span
lang=EN-US style='font-size:12.0pt'>I.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>热点缓存。</span></p>

<p class=MsoNormal style='text-indent:12.0pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; </span><span style='font-size:12.0pt;
font-family:宋体'>只缓存那些热点的数据。可以缓存在线的用户，　缓存热销的商品，　缓存热点用户的数据。热点规则表示如何匹配到一个热点，即这个查询请求是否请求了热点数据。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>根据</span><span lang=EN-US style='font-size:12.0pt'>2/8</span><span
style='font-size:12.0pt;font-family:宋体'>原则，小部分的数据占用了大部分的访问量。</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>这也就是</span><span lang=EN-US style='font-size:12.0pt'>twitter&nbsp; page
cache&nbsp; </span><span style='font-size:12.0pt;font-family:宋体'>是</span><span
lang=EN-US style='font-size:12.0pt'>40%</span><span style='font-size:12.0pt;
font-family:宋体'>，而不是</span><span lang=EN-US style='font-size:12.0pt'>90%</span><span
style='font-size:12.0pt;font-family:宋体'>的原因。</span></p>

<p class=MsoNormal><span style='font-size:12.0pt;font-family:宋体'>　</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; II.&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>非热点数据，</span><span lang=EN-US
style='font-size:12.0pt'> </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>可以采用</span><span lang=EN-US
style='font-size:12.0pt'>nosql</span><span style='font-size:12.0pt;font-family:
宋体'>技术（</span><span lang=EN-US style='font-size:12.0pt'>redies</span><span
style='font-size:12.0pt;font-family:宋体'>），可以把它看成可持久化的缓存。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>原理类似虚拟内存，理论上不受内存大小的限制。使用</span><span
lang=EN-US style='font-size:12.0pt'>NoSQL</span><span style='font-size:12.0pt;
font-family:宋体'>来做缓存，我们可以把一些不常访问、不怎么更新的数据也缓存起来。比如论坛、新闻的老数据、数据列表的靠后的页面，虽然用户访问不多，但是搜索引擎爬虫会访问，也可能导致系统负载上升。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>从外存拿数据减少了计算的开销</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>，由于其数据库结构的简单，从磁盘获取一次数</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>据也比从数据库一次耗时的查询划算很多。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; III.
read-only</span><span style='font-size:12.0pt;font-family:宋体'>缓存</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存是</span><span lang=EN-US
style='font-size:12.0pt'>read-only</span><span style='font-size:12.0pt;
font-family:宋体'>的，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>如果有</span><span lang=EN-US
style='font-size:12.0pt'>cache</span><span style='font-size:12.0pt;font-family:
宋体'>数据的更新，</span><span style='font-size:12.0pt'> </span><span style='font-size:
12.0pt;font-family:宋体'>把</span><span lang=EN-US style='font-size:12.0pt'>cache</span><span
style='font-size:12.0pt;font-family:宋体'>置为失效的。</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>如果有多个副本，这样做能够减少</span><span
lang=EN-US style='font-size:12.0pt'>replication</span><span style='font-size:
12.0pt;font-family:宋体'>更新数据的开销，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>只需要发送置失效的消息即可。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; 2. </span><span
style='font-size:12.0pt;font-family:宋体'>高并发更新场景</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:57.75pt;text-indent:-36.0pt'><span
lang=EN-US style='font-size:12.0pt'>I.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-size:12.0pt;font-family:宋体'>悲观锁方案：</span><span
style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span style='font-size:12.0pt;
font-family:宋体'>高并发更新，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>缓存会超时的场景可以使用</span><span lang=EN-US
style='font-size:12.0pt'>mutex</span><span style='font-size:12.0pt;font-family:
宋体'>锁。</span><span style='font-size:12.0pt;font-family:宋体'>如</span></p>

<ul type=disc>
 <li class=MsoNormal style='text-align:left'><span style='font-size:12.0pt;
     font-family:宋体'>首页<span lang=EN-US>top 10, </span>由数据库加载到<span lang=EN-US>memcache</span>缓存<span
     lang=EN-US>n</span>分钟</span></li>
 <li class=MsoNormal style='text-align:left'><span style='font-size:12.0pt;
     font-family:宋体'>微博中名人的<span lang=EN-US>content cache, </span>一旦不存在会大量请求不能命中并加载数据库</span></li>
</ul>

<p class=MsoNormal style='text-indent:21.75pt'><span style='font-size:12.0pt;
font-family:宋体'>在加载数据库之前先增加一个</span><span lang=EN-US style='font-size:12.0pt'>mutex
key</span><span style='font-size:12.0pt;font-family:宋体'>作为锁，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>成功之后再去做加载数据库，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>如果加锁失败则</span><span lang=EN-US
style='font-size:12.0pt'>sleep</span><span style='font-size:12.0pt;font-family:
宋体'>，之后重试读取原</span><span lang=EN-US style='font-size:12.0pt'>cache</span><span
style='font-size:12.0pt;font-family:宋体'>数据。为了防止死锁，锁也需要设置过期时间。</span><span
style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span style='font-size:12.0pt;
font-family:宋体'>乐观锁方案：</span><span style='font-size:12.0pt'> </span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>MVCC</span><span style='font-size:12.0pt;font-family:
宋体'>是后验性的，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突，由于没有锁，所以读写不会相互阻塞，从而大大提升了并发性能。修改过的副本带着版本号元数据，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>多个副本在合并时，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>根据版本检测冲突，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>并合并数据。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>Memcache </span><span style='font-size:12.0pt;
font-family:宋体'>通过客户端</span><span lang=EN-US style='font-size:12.0pt'>cas</span><span
style='font-size:12.0pt;font-family:宋体'>命令实现乐观锁。</span><span style='font-size:
12.0pt'> <span lang=EN-US>Jboss</span></span><span style='font-size:12.0pt;
font-family:宋体'>在</span><span lang=EN-US style='font-size:12.0pt'>3.0</span><span
style='font-size:12.0pt;font-family:宋体'>实现了</span><span lang=EN-US
style='font-size:12.0pt'>mvcc</span><span style='font-size:12.0pt;font-family:
宋体'>。</span><span style='font-size:12.0pt'> <span lang=EN-US>MVCC </span></span><span
style='font-size:12.0pt;font-family:宋体'>提供了非阻塞</span><span lang=EN-US
style='font-size:12.0pt'> (non-blocking) </span><span style='font-size:12.0pt;
font-family:宋体'>读操作</span><span lang=EN-US style='font-size:12.0pt'> ( </span><span
style='font-size:12.0pt;font-family:宋体'>它并不会去阻塞</span><span lang=EN-US
style='font-size:12.0pt'> wirter threads) </span><span style='font-size:12.0pt;
font-family:宋体'>，在避免死锁的同时也提供了更高级的并发机制。它采用了</span><span lang=EN-US
style='font-size:12.0pt'> fail-fast </span><span style='font-size:12.0pt;
font-family:宋体'>机制，如果写操作得到了一个</span><span lang=EN-US style='font-size:12.0pt'>
write lock </span><span style='font-size:12.0pt;font-family:宋体'>，那么它们也是依次进行，不允许重叠。</span></p>

<p class=MsoNormal style='text-indent:21.75pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>缓存：</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; Read-through&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>读贯穿</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;
Write-trrough&nbsp; </span><span style='font-size:12.0pt;font-family:宋体'>写贯穿</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;
Write-behind</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; </span></p>

<p class=MsoNormal style='text-indent:18.05pt'><b><span lang=EN-US
style='font-size:12.0pt'>Redies</span></b><b><span style='font-size:12.0pt;
font-family:宋体'>作为缓存的最佳实践</span></b></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; 1. </span><span
style='font-size:12.0pt;font-family:宋体'>对于全局公用的，构建成本比较低的数据，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>可以采用一致性</span><span lang=EN-US style='font-size:12.0pt'>hash</span><span
style='font-size:12.0pt;font-family:宋体'>，</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>无复制，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>无持久化的方案。</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>如果缓存</span><span lang=EN-US
style='font-size:12.0pt'>crash</span><span style='font-size:12.0pt;font-family:
宋体'>了，可以快速重新构建。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; 2. </span><span
style='font-size:12.0pt;font-family:宋体'>对于与用户相关的，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>一致性要求比较低的，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>构建成本较低的，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>可以采用多对一的复制方式，多个小容量的节点复制到同一个大容量的节点，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>但不提供持久化，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>提供较高的可用性。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp; 3. </span><span
style='font-size:12.0pt;font-family:宋体'>对于与用户相关的，一致性要求比较高的，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>构建成本比较高，但存储占用量不高的场景下，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>需要持久化，</span><span style='font-size:
12.0pt'> </span><span style='font-size:12.0pt;font-family:宋体'>并且一对一的复制方式，</span><span
style='font-size:12.0pt'> </span><span style='font-size:12.0pt;font-family:
宋体'>提供最高的可用性。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span style='font-size:12.0pt;
font-family:宋体'>案例：</span><span lang=EN-US style='font-size:12.0pt'> Twitter</span><span
style='font-size:12.0pt;font-family:宋体'>缓存体系</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;Twitter: </span><span style='font-size:12.0pt;
font-family:宋体'>逻辑缓存</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>－</span><span lang=EN-US
style='font-size:12.0pt'>&nbsp; page cache&nbsp;&nbsp;&nbsp; api</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='font-size:12.0pt;font-family:宋体'>－</span><span lang=EN-US
style='font-size:12.0pt'> fragment cache&nbsp;&nbsp;&nbsp; 1. </span><span
style='font-size:12.0pt;font-family:宋体'>原始数据的冗余</span><span lang=EN-US
style='font-size:12.0pt'> 2. </span><span style='font-size:12.0pt;font-family:
宋体'>结构上的冗余</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='font-size:12.0pt;font-family:宋体'>数据源</span><span lang=EN-US
style='font-size:12.0pt'>cache </span><span style='font-size:12.0pt;font-family:
宋体'>－</span><span lang=EN-US style='font-size:12.0pt'> vector cache</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row
cache</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; </span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; Page</span><span style='font-size:12.0pt;
font-family:宋体'>，</span><span lang=EN-US style='font-size:12.0pt'> fragment </span><span
style='font-size:12.0pt;font-family:宋体'>－</span><span style='font-size:12.0pt'>
</span><span style='font-size:12.0pt;font-family:宋体'>全局与局部的分离，</span><span
lang=EN-US style='font-size:12.0pt'> api</span><span style='font-size:12.0pt;
font-family:宋体'>，</span><span style='font-size:12.0pt'> </span><span
style='font-size:12.0pt;font-family:宋体'>业务逻辑</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; Vector, row cache – </span><span
style='font-size:12.0pt;font-family:宋体'>索引与内容的分离</span></p>

<p class=MsoNormal style='margin-left:16.5pt'><span lang=EN-US
style='font-size:12.0pt'>&nbsp; Google gfs cache </span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>Reference :</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-size:12.0pt'><a
href="http://www.infoq.com/cn/news/2011/03/nosql-architecture-practice-3">http://www.infoq.com/cn/news/2011/03/nosql-architecture-practice-3</a>
<a href="http://www.infoq.com/cn/news/2011/03/nosql-architecture-practice-3">NoSQL<span
lang=EN-US style='font-family:宋体'><span lang=EN-US>架构实践（三）</span></span>——<span
lang=EN-US style='font-family:宋体'><span lang=EN-US>以</span></span>NoSQL<span
lang=EN-US style='font-family:宋体'><span lang=EN-US>为缓存</span></span></a></span></p>

<h1><span lang=EN-US style='font-size:12.0pt'><a
href="http://wenku.baidu.com/view/018e3f2d7375a417866f8fbc.html">http://wenku.baidu.com/view/018e3f2d7375a417866f8fbc.html</a>&nbsp;
</span><span style='font-size:12.0pt'>大型网站架构系列之五<span lang=EN-US>,</span>缓存策略设计概要</span></h1>

<h1><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></h1>

<h2><span lang=EN-US style='font-size:12.0pt;line-height:173%'><a
href="http://timyang.net/programming/memcache-mutex/">http://timyang.net/programming/memcache-mutex/</a>&nbsp;
<a href="http://timyang.net/programming/memcache-mutex/"
title="Permanent Link to Memcache mutex设计模式">Memcache mutex<span lang=EN-US
style='font-family:黑体'><span lang=EN-US>设计模式</span></span></a></span></h2>

<h1><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></h1>

<h3><span lang=EN-US style='font-size:12.0pt;line-height:173%'><a
href="http://superleo.iteye.com/blog/265823">http://superleo.iteye.com/blog/265823</a>&nbsp;
<a href="http://superleo.iteye.com/blog/265823"><span lang=EN-US
style='font-family:宋体'><span lang=EN-US>深入理解</span></span>JBoss Cache3.0——Naga</a></span></h3>

<h1><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></h1>

<h1><span lang=EN-US style='font-size:12.0pt'><a
href="http://www.infoq.com/cn/articles/write-behind-caching">http://www.infoq.com/cn/articles/write-behind-caching</a>&nbsp;
<a href="http://www.infoq.com/cn/articles/write-behind-caching"><span
lang=EN-US><span lang=EN-US>极端事务处理模式：Write-behind</span></span><span
lang=EN-US><span lang=EN-US>缓存</span></span></a></span></h1>

<h2><span lang=EN-US style='font-size:12.0pt;line-height:173%'><a
href="http://timyang.net/programming/memcache-mutex/">http://timyang.net/programming/memcache-mutex/</a>&nbsp;
<a href="http://timyang.net/programming/memcache-mutex/"
title="Permanent Link to Memcache mutex设计模式">Memcache mutex<span lang=EN-US
style='font-family:黑体'><span lang=EN-US>设计模式</span></span></a></span></h2>

<h1><span lang=EN-US style='font-size:12.0pt'>&nbsp;</span></h1>

<h2><span lang=EN-US style='font-size:12.0pt;line-height:173%'><a
href="http://coolshell.cn/articles/6790.html">http://coolshell.cn/articles/6790.html</a>
</span><span style='font-size:12.0pt;line-height:173%;font-family:黑体'>多版本并发控制</span><span
lang=EN-US style='font-size:12.0pt;line-height:173%'>(MVCC)</span><span
style='font-size:12.0pt;line-height:173%;font-family:黑体'>在分布式系统中的应用</span></h2>

<p class=MsoNormal><b><span lang=EN-US>&nbsp;</span></b></p>

</div>

</body>

</html>
