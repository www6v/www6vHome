<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 12 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Calibri","sans-serif";}
h1
	{mso-style-link:"标题 1 Char";
	margin-right:0cm;
	margin-left:0cm;
	font-size:24.0pt;
	font-family:宋体;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Calibri","sans-serif";}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
span.Char
	{mso-style-name:"页眉 Char";
	mso-style-link:页眉;}
span.Char0
	{mso-style-name:"页脚 Char";
	mso-style-link:页脚;}
span.1Char
	{mso-style-name:"标题 1 Char";
	mso-style-link:"标题 1";
	font-family:宋体;
	font-weight:bold;}
 /* Page Definitions */
 @page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
-->
</style>

</head>

<body lang=ZH-CN link=blue vlink=purple style='text-justify-trim:punctuation'>

<div class=Section1 style='layout-grid:15.6pt'>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><b><span lang=EN-US style='font-size:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;</span></b><b><span
style='font-size:12.0pt;font-family:宋体'>领域逻辑和</span></b><b><span lang=EN-US
style='font-size:12.0pt'>SQL</span></b></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>在企业应用中，</span>
<span style='font-family:宋体'>业务逻辑是复杂和庞杂的。</span> <span style='font-family:宋体'>这些业务逻辑应该是被显示，</span>
<span style='font-family:宋体'>还是被隐藏，</span> <span style='font-family:宋体'>这是一种选择。</span>
<span style='font-family:宋体'>在工作流中，</span> <span style='font-family:宋体'>业务逻辑被从模块中剥离出来，</span>
<span style='font-family:宋体'>形成上层的粗粒度的业务流程。</span> <span style='font-family:
宋体'>在模块内部，</span> <span style='font-family:宋体'>业务逻辑应该放在内存中，</span> <span
style='font-family:宋体'>还是在</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>中，</span> <span style='font-family:宋体'>这也是一种选择。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>拨开项目的</span><span
lang=EN-US>DAO</span><span style='font-family:宋体'>层，</span> <span
style='font-family:宋体'>你可能会看到大量的</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>字符串，</span> <span style='font-family:宋体'>业务逻辑就隐藏在这里。在有的项目你会看到</span><span
lang=EN-US>hibernate</span><span style='font-family:宋体'>之类的</span><span
lang=EN-US>ORM</span><span style='font-family:宋体'>框架，</span><span lang=EN-US>
PO</span><span style='font-family:宋体'>对象作为一种承载业务逻辑的机制。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>大量复杂的</span><span
lang=EN-US>SQL</span><span style='font-family:宋体'>拼接，</span> <span
style='font-family:宋体'>在</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>中放入业务逻辑与企业应用架构的分层原则相违背。</span><span lang=EN-US>OO</span><span
style='font-family:宋体'>的本质是抽象和分离，</span> <span style='font-family:宋体'>各司其责。</span>
<span style='font-family:宋体'>领域逻辑更符合</span><span lang=EN-US>OO</span><span
style='font-family:宋体'>的精神。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>领域逻辑中的</span><span
lang=EN-US>ORM</span><span style='font-family:宋体'>不仅是一种可重用的对象装载方式，</span> <span
style='font-family:宋体'>也是一种虚拟化技术。对象与数据库的映射机制由</span><span lang=EN-US>ORM</span><span
style='font-family:宋体'>管控，对象装载和业务逻辑的分离，</span> <span style='font-family:宋体'>表对于对象来说是透明的。就像</span><span
lang=EN-US>JVM</span><span style='font-family:宋体'>，</span> <span
style='font-family:宋体'>硬件对于</span><span lang=EN-US>Java</span><span
style='font-family:宋体'>工程师来说是透明的一样。</span> </p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>在</span><span
lang=EN-US>Domain Logic</span><span style='font-family:宋体'>和</span><span
lang=EN-US>SQL</span><span style='font-family:宋体'>之间，</span> <span
style='font-family:宋体'>中庸的是</span><span lang=EN-US>Trasaction Script</span><span
style='font-family:宋体'>（事务脚本），它根据过程组织业务逻辑，每个过程处理来自表现层的一个单一请求。事务脚本简单的可以看成</span><span
lang=EN-US>Domain Logic</span><span style='font-family:宋体'>和</span><span
lang=EN-US>Native SQL</span><span style='font-family:宋体'>的结合。</span> </p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>Native SQL</span><span
style='font-family:宋体'>的拥护者会提到</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>的性能优势。在多表查询中，</span><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>确实没有</span><span lang=EN-US>Native SQL</span><span
style='font-family:宋体'>快。</span> <span style='font-family:宋体'>在一条</span><span
lang=EN-US>SQL</span><span style='font-family:宋体'>即一个事务情况下，</span><span
lang=EN-US>Native SQL</span><span style='font-family:宋体'>会快些。</span> <span
style='font-family:宋体'>但在</span><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>中，</span><span lang=EN-US> framework</span><span
style='font-family:宋体'>会使用</span><span lang=EN-US>cache</span><span
style='font-family:宋体'>做局部性的优化，</span> <span style='font-family:宋体'>并且</span><span
lang=EN-US>cache</span><span style='font-family:宋体'>的对象是能够跨多个事务复用的（</span><span
lang=EN-US>hibernate</span><span style='font-family:宋体'>二级缓存），</span> <span
style='font-family:宋体'>缓存策略也是可配置的。</span><span lang=EN-US>Framework</span><span
style='font-family:宋体'>并且提供</span><span lang=EN-US>Lazy load</span><span
style='font-family:宋体'>机制，在使用时加载对象，</span> <span style='font-family:宋体'>进一步提升性能。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>可以在可理解的代码上做性能的改进，找到那占用了</span><span lang=EN-US>80%</span><span
style='font-family:宋体'>时间的</span><span lang=EN-US>20%</span><span
style='font-family:宋体'>的代码。</span> <span lang=EN-US>Native SQL</span><span
style='font-family:宋体'>可以在高性能的代码上做理解性的改进，</span> <span style='font-family:宋体'>但</span><span
lang=EN-US>sql</span><span style='font-family:宋体'>中的逻辑是隐式的，</span> <span
style='font-family:宋体'>笔者认为要做到后者不易。</span> <span style='font-family:宋体'>维护占到了软件生命周期的很大一部分，</span>
<span style='font-family:宋体'>应该先关注可修改性，</span> <span style='font-family:宋体'>再关注性能。性能的第一原则是“不要提早优化”。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>在长生命周期的企业软件中，需求的迭代和代码的迭代是常态。</span>
<span style='font-family:宋体'>改变可能是人们把业务逻辑放在内存中，</span> <span style='font-family:
宋体'>使用</span><span lang=EN-US>Domain Logic</span><span style='font-family:宋体'>的主要原因。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>过度复杂的</span><span
lang=EN-US>sql</span><span style='font-family:宋体'>拼接让人很难理解，</span> <span
style='font-family:宋体'>面条代码，</span> <span style='font-family:宋体'>逻辑不连贯现象容易形成。</span>
<span style='font-family:宋体'>在</span><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>的基础上，</span><span lang=EN-US> DSL</span><span
style='font-family:宋体'>（</span><span lang=EN-US>Domain Specific Language</span><span
style='font-family:宋体'>）提供了连贯接口，</span> <span style='font-family:宋体'>业务清晰一目了然。</span></p>

<p class=MsoNormal><span style='font-family:宋体'>当然在理解程度上，</span> <span
style='font-family:宋体'>有人更适应</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>，</span> <span style='font-family:宋体'>有人更适应</span><span
lang=EN-US>Domain Logic</span><span style='font-family:宋体'>，</span> <span
style='font-family:宋体'>这也是仁者见仁了。</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='margin-left:5.25pt;text-indent:15.75pt'><span
lang=EN-US>Native SQL</span><span style='font-family:宋体'>中的</span><span
lang=EN-US>sql</span><span style='font-family:宋体'>的重用比</span><span lang=EN-US>Domain
Logic</span><span style='font-family:宋体'>中对象的重用更困难。</span> <span
style='font-family:宋体'>如果想重用一段</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>，在</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>中嵌入了判断逻辑，</span><span lang=EN-US>SQL</span><span
style='font-family:宋体'>的复杂度又就增加了。数据库视图是表的接口，可以定义一个视图，</span><span lang=EN-US>
query</span><span style='font-family:宋体'>重用定义好的视图。但视图有局限性，</span> <span
style='font-family:宋体'>只有</span><span lang=EN-US>select</span><span
style='font-family:宋体'>操作，</span> <span style='font-family:宋体'>没有</span><span
lang=EN-US>update</span><span style='font-family:宋体'>操作，</span> <span
style='font-family:宋体'>如果有</span><span lang=EN-US>DML</span><span
style='font-family:宋体'>要求，</span> <span style='font-family:宋体'>还需要定义存储过程。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>使用视图和存储过程提供的封装是不完全的。</span>
<span style='font-family:宋体'>在企业应用中，数据会来源于多个数据源，</span> <span style='font-family:
宋体'>多个数据库，</span><span lang=EN-US> xml</span><span style='font-family:宋体'>文件，</span><span
lang=EN-US>nosql</span><span style='font-family:宋体'>数据库，</span> <span
style='font-family:宋体'>遗留系统等。</span> <span style='font-family:宋体'>在这个情况中，数据存取的完全封装确实只能在应用的分层中实现。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>提供了抽象层次和模块化的机制，</span> <span style='font-family:宋体'>对象装载和实际业务的分离，</span>
<span style='font-family:宋体'>好的对象装载机制会零入侵业务逻辑，如果</span><span lang=EN-US>Annotation</span><span
style='font-family:宋体'>用的是</span><span lang=EN-US>JSR</span><span
style='font-family:宋体'>标准，</span> <span style='font-family:宋体'>把</span><span
lang=EN-US>hibernate</span><span style='font-family:宋体'>替换成</span><span
lang=EN-US>OpenJPA</span><span style='font-family:宋体'>也比较容易。</span> </p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>Domain Logic</span><span
style='font-family:宋体'>要求对</span><span lang=EN-US>framework</span><span
style='font-family:宋体'>有好的把握，</span> <span style='font-family:宋体'>一定的驾驭能力，</span>
<span style='font-family:宋体'>问题的解决能力。</span><span lang=EN-US> Domain Logic</span><span
style='font-family:宋体'>里的对象有更多的约束条件，更多的模式，</span> <span style='font-family:
宋体'>比如一对一，多对一，多对多。</span> <span lang=EN-US>&nbsp;SQL</span><span
style='font-family:宋体'>相对更容易掌握，</span> <span style='font-family:宋体'>代码直接可控。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>如果想要有可移植性，请不要使用</span><span
lang=EN-US>sql</span><span style='font-family:宋体'>。</span> <span
style='font-family:宋体'>各个语言都有自己的方言，</span> <span style='font-family:宋体'>语法有略微的不同。</span><span
lang=EN-US>Id</span><span style='font-family:宋体'>的增长方式不同，有</span><span
lang=EN-US>sequence</span><span style='font-family:宋体'>，</span> <span
style='font-family:宋体'>有自增的，</span> <span style='font-family:宋体'>有全局的。</span><span
lang=EN-US>Mysql</span><span style='font-family:宋体'>有</span><span lang=EN-US>limit</span><span
style='font-family:宋体'>关键字，</span><span lang=EN-US>oracle</span><span
style='font-family:宋体'>有</span><span lang=EN-US>rowid</span><span
style='font-family:宋体'>和</span><span lang=EN-US>rownum, db2</span><span
style='font-family:宋体'>有</span><span lang=EN-US>ROW_NUMBER() over(). </span><span
style='font-family:宋体'>如果有数据库移植的需求，</span> <span style='font-family:宋体'>已经写的</span><span
lang=EN-US>Native SQL</span><span style='font-family:宋体'>就会有大的改动。</span> </p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:宋体'>参考：</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US><a
href="http://martinfowler.com/articles/dblogic.html"><span style='color:windowtext;
text-decoration:none'>http://martinfowler.com/articles/dblogic.html</span></a>&nbsp;&nbsp;
&nbsp;Domain Logic and SQL</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US>&nbsp;</span></p>

</div>

</body>

</html>
